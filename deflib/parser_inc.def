include: input_buffer.def
include: regex_vm.def

include: c_darray.def

# -------
subcode:: _autoload
    $struct(token) int id, char val[8]
    $call global_darray, struct token, p_token_stack
    $call global_darray, int, p_token_count
    $global n_token_count=0
    $(block:main_init)
	$map check_size_assumption, char *, int, double

subcode: check_size_assumption(type)
    $if sizeof($(type))>8
	print "sizeof($(type)) too big"
	exit(1)

fncode: push_token(n_id)
    $return_type void *
    $call darray_check, p_token_stack
    p_token_stack[p_token_stack_len].id=n_id
    p_token_stack_len++
    return &p_token_stack[p_token_stack_len-1].val

fncode: push_count(n)
    $call da_push, p_token_count, n

# ----
subcode: push_token_number(number)
    $define(number) 20001
    *((double*)push_token(number))= $(number)

subcode: get_token_string(item, ts_val)
    $(ts_val)=*((char**)$(item).val)

subcode: get_token_number(item, tf_val)
    $local double $(tf_val)
    $(tf_val)=*((double*)$(item).val)

subcode: pop_keyword(tn_keyword)
    $call da_pop, p_token_stack
    $(tn_keyword)=$(item).id

subcode: pop_string(ts_val)
    $call da_pop, p_token_stack
    $call get_token_string, $(item), $(ts_val)

subcode: pop_count(tn_count)
    $call da_pop, p_token_stack
    $(tn_count)=*(int*)$(item).val

subcode: pop_number(tf_val)
    $call da_pop, p_token_stack
    $if $(item).id!=number
	print "Parse error: number expected, got [%d]\n", $(item).id
	exit(1)
    $else
	$call get_token_number, $(item), $(tf_val)

# ----------------------------------------
subcode:: _autoload
    $global int prog_token=0
    $global struct input_buffer * prog_input=NULL
    $global struct regex_vm *     prog_vm=NULL

    $list LA, match
    $list push_token, push_count

fncode: LA
    $call look_ahead
    return prog_token

fncode: match(n_token)
    $call look_ahead
    $if prog_token == n_token
	return 1
    $else
	return 0

subcode: look_ahead
    $if !prog_token
	fetch_token:
	prog_token=regex_vm_match(prog_vm, prog_input)
	$call @skip_tokens

# subcode skip_tokens should be generated in parser.def, which calls skip_token(token)
subcode: skip_token(token)
    $case prog_token==$(token)
	$(if:hascode:on_$(token))
	    $call on_$(token)
	goto fetch_token
    # ----------------------------------------
subcode: match_error
    print Parse error: Expecting $(token), Got [$prog_token]
    exit(1)

subcode: match_keyword(token)
    $if !match($(token))
	$call match_error
    $else
	$call consume_token

subcode: match_term(token)
    $if !match($(token))
	$call match_error
    $else
	$(if:hascode:on_$(token))
	    $call on_$(token)
	$(else)
	    $call grab_token
	$call consume_token

subcode: consume_token
    prog_token=0

subcode: grab_token
    $local void * tp
    tp=push_token(prog_token)
    $if prog_token >= KEYWORD_MAX
	*((char **)tp)=input_dup_str(prog_input)
    n_token_count++

subcode: push_token_count
    push_count(n_token_count)
    n_token_count=0

subcode: pop_token_count
    $call da_pop, p_token_count
    n_token_count=$(item)
    n_token_count++

subcode: on_parse_finish(name)
    $(if:hascode:on_$(name))
	$call @on_$(name)
    $(else)
	$if n_token_count>1
	    *((int *)push_token($(name)))=n_token_count

# ----------------------------------------
subcode: print_stack
    $call use_darray, p_token_stack
    $(set:id=p_token_stack[i].id)
    $(set:val=p_token_stack[i].val)
    $for i=0:$(len)
	$if $(id)<KEYWORD_MAX
	    printf "%d: keyword %d\n", i, $(id)
	$elif $(id)<10000
	    printf "%d: terminal %d %s\n", i, $(id), *((char**)&$(val))
	$elif $(id)==number
	    printf "%d: number %g\n", i, *((double*)&$(val))
	$else
	    printf "%d: ", i
	    $call print_rule_name, $(id)
	    printf " [%d]\n", *((int*)&$(val))
