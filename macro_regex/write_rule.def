include: macro_regex/first_set.def

subcode: parse_grammar
    my @fnlist
    &call topdown_loop, name, $top_symbol
	my $rulelist=$rules{$name}
	$indent=0
	push @fnlist, "parse_$name"
	$call do_print, "fncode: parse_$name"
	$indent++
	$if @$rulelist==1
	    do_rule($rulelist->[0], $indent, \@name_list)
	$else
	    $call check_left_factors

	    my @i_list
	    $for $i=0:@$rulelist
		push @i_list, $i
	    do_rule_pre_factor(0, $rulelist, \@i_list, $indent, \@name_list)
	$call do_print_ln

    my $indent=0
    $call do_print, "subcode:: _autoload"
    $indent++
    $call do_print, "\$list ", join(', ', @fnlist)

# --------------------------------
subcode:: _autoload
    $sub do_rule($rule, $indent, $nonterm_list)
	my $error
	my $type=$rule->{type}
	$if $type=~/^(keyword|term)$/
	    $call do_print, "match($rule->{value})"
	$elif $type eq "nonterm"
	    $call do_print, "parse_$rule->{value}()"
	    $if defined $nonterm_list
		push @$nonterm_list, $rule->{value}
	$elif $type eq "group"
	    my $tlist=$rule->{value}
	    $call @check_group_ambiguity, $tlist
	    $foreach $t in @$tlist
		do_rule($t, $indent, $nonterm_list)
	$elif $type eq "*" or $type eq "?"
	    my $first_set=get_first($rule->{value})
	    $call get_look_ahead, $first_set
	    my $switch="\$if"
	    $if $rule->{type} eq "*"
		$switch="\$while"
	    $call do_print, "$switch $lookahead"
	    do_rule($rule->{value}, $indent+1, $nonterm_list)
	$elif $type eq "empty"
	    # skip
	$elif $type eq "alt"
	    my $rlist=$rule->{value}
	    my $flag=1
	    $foreach $r in @$rlist
		$if $r->{type} !~/^(keyword|term)$/
		    $flag=0
	    $if $flag
		$call do_print, "grab_token()"
	    $else
		$error=1
	$else
	    $error=1

	$if $error
	    print "    "x$indent
	    print "# "
	    print_rule($rule)
	    print "\n"

    $sub do_rule_factor($k, $rulelist, $i_list, $indent, $nonterm_list)
	$call get_rule_list, $rulelist->[$i_list->[0]], $rlist
	my $factor=$rlist->[$k]->{factor}
	$while $k<@$rlist and $rlist->[$k]->{factor} eq $factor
	    do_rule($rlist->[$k], $indent, $nonterm_list)
	    $k++

	do_rule_pre_factor($k, $rulelist, $i_list, $indent, $nonterm_list)

# --------------------------------
subcode:: _autoload
    $sub do_rule_pre_factor($k, $rulelist, $i_list, $start_indent, $nonterm_list)
	my $num_total=@$i_list
	my $num_remain=$num_total
	# $call @check_token_ambiguity
	$call get_alt_set
	$for $i=0:$num_total
	    my $indent=$start_indent
	    my $r=$alt_set[$i]
	    #print "alt #$i: $r->{type} $num_remain/$num_total\n"
	    $if $num_remain==1
		$call do_print_else
		$call do_rule_r
	    $else
		$call get_rule_list, $r, $rlist
		$if !defined $rlist->[0]->{factor}
		    $call do_print_LA1
		    $call do_rule_r
		$elif $rlist->[0]->{factor} eq "1"
		    # skip
		$else
		    my @factors=split /-/, $rlist->[0]->{factor}
		    $if $num_remain==@factors
			$if $num_remain<$num_total
			    $call do_print_else
		    $else
			$call do_print_LA1
		    do_rule_factor($k, $rulelist, \@factors, $indent, $nonterm_list)

subcode: do_print_else
    $call do_print, "\$else"
    $indent++

subcode: do_print_LA1
    my $set=get_first($r)
    $call get_look_ahead, $set
    $call do_print, "\$case $lookahead"
    $indent++

subcode: do_rule_r
    do_rule($r, $indent, $nonterm_list)
    $call do_print, "# alt $r->{index}"
    $num_remain--

# -----
subcode: get_alt_set
    my @alt_set
    my $empty_alt
    $foreach $i in @$i_list
	my $r=$rulelist->[$i]
	$if $k==0
	    $r->{index}=$i
	    push @alt_set, $r
	$elif $r->{type} ne "group" && $k==1
	    $call set_empty_alt
	$else
	    my $tlist=$r->{value}
	    $if $k>=@$tlist
		$call set_empty_alt
	    $else
		my @t
		$for $j=$k:@$tlist
		    push @t, $tlist->[$j]
		push @alt_set, {type=>"group", value=>\@t, index=>$i}
    $if $empty_alt
	push @alt_set, {type=>"empty", index=>$empty_alt}

subcode: set_empty_alt
    $if defined $empty_alt
	die "multiple empty cases\n"
    $empty_alt=$i

# ------------------------------------------------

subcode: get_look_ahead(set)
    my @t
    $for $t in @$(set)
	push @t, "LA(1)==$t"
    my $lookahead=join(" || ", @t)

# == AMBIGUITY CHEC ============================
# Detect: (exp ',')* exp
subcode: check_group_ambiguity(list)
    my @temp_set
    my $i=0
    my $first_set=get_first($(list)->[0])
    $while $i+1<@$(list)
	my $second_set=get_first($(list)->[$i+1])
	$if $empty_set_hash{$(list)->[$i]} 
	    push @temp_set, @$first_set
	    $foreach $t2 in @$second_set
		$foreach $t1 in @temp_set
		    $if $t2 eq $t1
			print "Ambiguity: "
			print_rule($(list)->[$i])
			print_rule($(list)->[$i+1])
			print " [$t2]\n"
			die
	$else
	    @temp_set=()
	$first_set=$second_set
	$i++

# Detect: ID | ID '(' explist ')'
subcode: check_token_ambiguity
    $for $j=$i+1:$num_total
	my $t_set=$alt_set[$j]
	$foreach $t1 in @$set
	    $if grep {$_ eq $t1} @$t_set
		print "Ambiguity: $name\n"
		print "    "
		print_rule($rulelist->[$i])
		print "\n"
		print "    "
		print_rule($rulelist->[$j])
		print "\n"
		die

# -- Left Factoring --------------------------------
subcode: check_left_factors
    $for $i=0:@$rulelist
	$call get_rule_list, $rulelist->[$i], $list_i
	$for $j=$i+1:@$rulelist
	    $call get_rule_list, $rulelist->[$j], $list_j
	    $for $k=0:@$list_i
		my $a=$list_i->[$k]
		my $b=$list_j->[$k]
		$if $a->{factor}==1 
		    next
		$elif $a->{type} eq $b->{type} && $a->{value} eq $b->{value}
		    $if !$a->{factor}
			$a->{factor}="$i"
		    $a->{factor}.="-$j"
		    $b->{factor}=1
		$else
		    last
    # $call print_left_factors

subcode: print_left_factors
    $for $i=0:@$rulelist
	$call get_rule_list, $rulelist->[$i], $list_i
	$for $k=0:@$list_i
	    my $a=$list_i->[$k]
	    print "[$a->{factor}] "
	print "\n"


# ===============================
subcode: get_rule_list(rule, rlist)
    my $rule=$(rule)
    my $(rlist)
    $if $rule->{type} eq "group"
	$(rlist)=$rule->{value}
    $else
	$(rlist)=[$rule]


