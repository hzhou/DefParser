include: macro_regex/parse_regex.def
include: macro_regex/build_nfa.def
include: macro_regex/vm.def

subcode:: _autoload
    $call init_KeyName

    $sub get_keyname($key)
	$call generate_keyword_name($key)
	return $name

subcode: generate_lex
    my @tree
    my $count=0
    $foreach $name in @lex_keywords
	my $str=$lex_rules{$name}
	my $re=parse_regex_keyword($str, $name)
	push @tree, @$re
	$count++
    $foreach $name in @lex_tokens
	my $pattern=$lex_rules{$name}
	my $re=parse_regex($pattern, $name)
	push @tree, @$re
	$count++

    $for $i=1:$count
	push @tree, "]|"
    my $vm=build_vm(build_nfa(\@tree))
    # $call print_vm_c, lex

subcode: add_regex(name, pattern)
    $global %lex_rules
    $global @lex_tokens
    push @lex_tokens, $(name)
    $lex_rules{$(name)}=$(pattern)

subcode: generate_keyword_name(k)
    $global @lex_keywords

    my @t
    $for $i=0:length($(k))
	my $c=substr($(k), $i, 1)
	$if $KeyName{$c}
	    push @t, $KeyName{$c}
	$elif $c=~/[0-9]/
	    push @t, $c
	$elif $c=~/[a-zA-Z]/
	    push @t, uc($c)
	$else
	    die "Missing KeyName for '$c'\n"
    my $name=join('', @t)
    $if $name=~/^\d/
	$name="_$name"
    $if $lex_rules{$name} and $lex_rules{$name} ne $(k)
	my $tid=2
	$while $lex_rules{"$name\_$tid"} and $lex_rules{"$name\_$tid"} ne $(k)
	    $tid++
	$name="$name\_$tid"

    push @lex_keywords, $name
    $lex_rules{$name}=$(k)



subcode: init_KeyName
    my %KeyName=(
	'(' => "Lp",
	')' => "Rp",
	'>' => "Gt",
	'<' => "Lt",
	'=' => "Eq",
	'*' => "Star",
	'/' => "Slash",
	'+' => "Plus",
	'-' => "Minus",
	'!' => "Not",
	'^' => "Ctrl",
	'@' => "At",
	'#' => "Pound",
	'$' => "Dollar",
	'%' => "Percent",
	'&' => "And",
	'[' => "Lb",
	']' => "Rb",
	'{' => "Lc", 
	'}' => "Rc",
	':' => "Colon",
	';' => "Semicolon",
	'`' => "Lq",
	"'" => "Rq",
	'"' => "Dq",
	',' => "Comma",
	'.' => "Dot",
	'?' => "Qm",
	'|' => "Or",
	'\\'=> "Bs",
	)

